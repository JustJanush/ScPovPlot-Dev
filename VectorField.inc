/****h* ScPovPlot3D/VectorField.inc
* PURPOSE
*   This module is in introductory state.
*   It contains macros for representation of vector field in form of set of vectors symbolised by
*   various shapes and color coding systems. Direction and strength of vector at given space point
*   can be visualised in different ways. While direction of the vector can be shown by main axis
*   of some figure, for example cone or cylinder, strength and turn can be represented by length
*   or color or volume or so on. It depends mainly on the goal of visualisation.
*   I think, that representation of vectors in single plane is most informative by now.
*   Besides that we need superimposition of source objects, as coils, charges, permanent magnet
*   poles or even oceanic bed  if one takes into account visualisation of oceanic currents.
*     image:./imgs/VectorFieldS.jpg
*     |html <hr width=50% align="left">
*   Fig.[VectorField] Example of vector field generated by point charge at the center of Cartesian system rendered with this module
*   |html <hr width=50% align="left">
* VERSION
*  3.1.0.6, tested on PovRay 3.7.
* AUTHOR
*  Janusz Opi³a Ph.D.
*   jmo{at}agh.edu.pl, janusz.opila{at}gmail.com
*   Dept. of Applied Informatics,
*   href:https://www.facebook.com/KatedraInformatykiStosowanejWZAGH/
*   href:http://kis.zarz.agh.edu.pl/
*   AGH University of Science & Technology, Cracow, Poland href:http://www.zarz.agh.edu.pl/English/index.asp
*   Maintained by Janusz Opi³a Ph.D.
*   Homepage: http://scpovplot3d.sourceforge.net
* COPYRIGHT
*  GNU GPL v.3 License
*  (c) 2012-now by Janusz Opi³a Ph.D.
*  AGH University of Science and Technology
*
****
  end of RoboDoc comment
****/

#ifndef(VectorFields_INC)
#declare VectorFields_INC = "2016-05-29";
#version 3.7;

#local _FileName   = "VectorFields.INC";
#local _FileVerMaj = "3.2.0.6";
#local _FileVerMin = VectorFields_INC;
#debug concat("\n[==> ", _FileName,", ver: ", _FileVerMaj, ", build:  ", _FileVerMin, " <==]\n")

#ifndef (Debug) // Just 4 safety
   #declare Debug=0;
#end

#include "colors.inc"
#include "textures.inc"
//====================
#include "Cameras.inc"
#include "ColorMaps.inc"
#include "PeriodicTable.inc"

// some defaults
/****iv* VectorField.inc/_Npmax, _StrmLinRadius, _EndingPointRad, _FatCoefficient, _Flux, __1byPi__ 
* PURPOSE
*  _StrmLinRadius  - streamline body radius
*  _EndingPointRad - streamline endings (spheres) diameter, internal global variable
*  _FatCoefficient - used by ComputeFatStreamline macro variant of ComputeStreamline. Moderates scaling of the field strength
*  _Flux           - assumed vector field flux along tubeline
* SEE ALSO
*  One should also refer to:
*   None
* SYNOPSIS
*/
#declare _Npmax = 1;   
#declare _StrmLinRadius  = 0.03; // streamline body radius, if == '0', _FatCoefficient is used for variable diameter streamlines. 
#declare _EndingPointRad = 0.05; // streamline endings (spheres) diameter, internal global variable
#declare _Flux           = 1.00; // vextor field flux, expressed in adopted in the job units, eg. [T*m^2], [V*angstroem], and so on.
#declare _FatCoefficient = 1.00; // used by ComputeStreamline. Additional scaling of the fluxline diameter, for use with 
                                 // derivative units like V->kV, A/m=>kA/m; 
#declare __1byPi__       = 1.0/sqrt(pi); // remove? - constant coefficient for fluxlines;                                  
/*******/

/****f* VectorField.inc/DeclareVectors
* PURPOSE
*   calculates field using function _VS given as parameter, in _NP^3 grid points in a cube
*     image:./imgs/VectorFieldExS.jpg
*     |html <hr width=50% align="left">
*   Fig.[VectorFieldCube] Example of vector field generated by point charge at the center of Cartesian system rendered with this module over 7x7x7 3D space grid
*
* SYNOPSIS 
*/
#macro DeclareVectors (_VS, _NP)
/*
* INPUTS                 
*  _VS - float function(float, float) - inline function two float parameters, returns float
*  _NP - integer - size of the grid, number of nodes along one cube edge                                            
******/                  
    #declare _Npmax= _NP*_NP*_NP;
    #declare SpcPntsVecs = array[_Npmax][3]; // [][0] - space point, [][1] field vector direction, [][2] field strength
    #for(iz, 0, _NP-1)
        #for(iy, 0, _NP-1)
            #for(ix, 0, _NP-1)
                #local indx = _NP*_NP*iz+_NP*iy+ix ;
                #declare SpcPntsVecs[indx][0] = <ix+.2, iy+.2, iz+.2>;
                #declare VL = vlength(SpcPntsVecs[indx][0]);
                #declare SpcPntsVecs[indx][1] = SpcPntsVecs[indx][0]/VL;
                #declare SpcPntsVecs[indx][2] = <_VS(QQ, VL),0,0>; // THIS Line needs refinment
            #end
        #end
    #end
#end                     

/*
TODO:
"Field measured on Hawaii on 2012-12-12",
111,
x, y, z, vx, vy, vz // position <x,y,z>_REAL! and vector strength <vx, vy, vz>_REAL
x, y, z......
*/
#macro ImportVectors(_filenam)
   #fopen DataFile _filenam read
   #read(DataFile, _Descript)
   #read(DataFile, _NumPts)


        #for(iz, 0, NP-1)
            #for(iy, 0, NP-1)
                #for(ix, 0, NP-1)
                    #local indx = NP*NP*iz+NP*iy+ix ;
                    #declare SpcPntsVecs[indx][0] = <ix+.2, iy+.2, iz+.2>;
                    #declare VL = vlength(SpcPntsVecs[indx][0]);
                    #declare SpcPntsVecs[indx][1] = SpcPntsVecs[indx][0]/VL;
                    #declare SpcPntsVecs[indx][2] = <_VS(QQ, VL),0,0>; // THIS Line needs refinment
                #end
            #end
        #end

    #fclose
#end
        
        
// Oriented glyphs        
#macro DrawVectorField()
    #declare VF = union{
        #for(SpcPnt, 0, _Npmax-1)
           #declare VL = vlength(SpcPntsVecs[SpcPnt][1]);
           cone{<0, 0, 0>, Rr, SpcPntsVecs[SpcPnt][1], 0
                  texture{
                     pigment {
                         gradient SpcPntsVecs[SpcPnt][1]
                         color_map {
                              [0.00 color rgbt<.0, .0, .13, .0>]
                              [0.30 color rgbt<.0, .0, .33, .0>]
                              [0.33 color rgbt<.7, .7, .7, .0>]
                              [0.36 color rgbt<.3, .0, .0, .0>]
                              [1.00 color rgbt<.5, .0, .0, .0>]
                         }
                         scale 1.05*VL
                         translate -0.025*SpcPntsVecs[SpcPnt][1]/VL
                      }
                      finish{ phong .3 reflection .5 diffuse .3 ambient .9 }
                  }
                  translate -0.33*SpcPntsVecs[SpcPnt][1]/VL
                  scale ScFac*SpcPntsVecs[SpcPnt][2].x
                  translate SpcPntsVecs[SpcPnt][0]
           }

        #end
    };

    object{VF}
#end

#macro DrawVectorFieldByColor(_gam, _Trsh) // the more power the more saturated colors are - gray means zero field                          
// firstly, find min and max, make them global
    #declare _MinVec = SpcPntsVecs[0][2].x;                                                 
    #declare _MaxVec = _MinVec;
    #for(SpcPnt, 0, _Npmax-1)
       #declare _VL = SpcPntsVecs[SpcPnt][2].x;                                                 
       #declare _MinVec = ((_MinVec>_VL)?_VL:_MinVec);
       #declare _MaxVec = ((_MaxVec<_VL)?_VL:_MaxVec);         
    #end   

    #declare _VF = union{
        #for(SpcPnt, 0, _Npmax-1)
           #declare _VL = SpcPntsVecs[SpcPnt][2].x;                                  
           #declare _Satur = pow((_VL-_MinVec)/(_MaxVec-_MinVec),1.0/_gam);
           #declare _C01 = CHSV2RGB(<240, _Satur, _Satur, 0, 0>); 
           #declare _C02 = CHSV2RGB(<240, _Satur, _Satur/3, 0, 0>)+.1;
           #declare _C03 = CHSV2RGB(<  0, 0, .7, 0, 0>)     ;
           #declare _C04 = CHSV2RGB(<  0, _Satur, .5, 0, 0>);                      
           #declare _C05 = CHSV2RGB(<  0, _Satur, _Satur/3, 0, 0>+.1);                      
               
           cone{<0, 0, 0>, Rr, 1*SpcPntsVecs[SpcPnt][1], 0 
                  texture{ 
                     pigment { color (_Satur<_Trsh?_C02:_C05)}
                      finish{ phong .3 reflection .5 diffuse .3 ambient .9 }
                  }                               
                  translate -0.33*SpcPntsVecs[SpcPnt][1]               
                  scale .05
                  translate SpcPntsVecs[SpcPnt][0]                  
           }
    
        #end   
    };                                            

    object{_VF}
#end                                 

#macro DeclareVectorsSphere(_VS, _NP)       
    #declare _Npmax= _NP*_NP*_NP;        
    #declare SpcPntsVecs = array[_Npmax][3]; // [][0] - space point, [][1] field vector direction, [][2] field strength

    #for(iz, 0, _NP-1)
        #for(iy, 0, _NP-1)
            #for(ix, 0, _NP-1)                                                  
                #local indx = _NP*_NP*iz+_NP*iy+ix ;
                #declare SpcPntsVecs[indx][0] = <(iy+1)*cos(radians(iz*180/(_NP)-90))*sin(ix*radians(360/(_NP))), (iy+1)*sin(radians(iz*180/(_NP)-90)), (iy+1)*cos(radians(iz*180/(_NP)-90))*cos(ix*radians(360/(_NP)))>/15;
                #declare VL = vlength(SpcPntsVecs[indx][0]);                                    
                #declare SpcPntsVecs[indx][1] = SpcPntsVecs[indx][0]/VL;   // direction
                #declare SpcPntsVecs[indx][2] = <_VS(QQ, VL),0,0>;         // power- THIS Line needs refinment           
            #end   
        #end                      
    #end   
#end



// Streamlines
/****M* Potential.inc/DeclareStructure
* PURPOSE
*  Sets internal variable _Pts, utilized by VectoCF macro for vector field computations
* SYNOPSIS
*/
#macro DeclareStructure (_Atoms)
/*
* INPUTS
*  garray - structure table, see Potential.inc
* OUTPUTS
*  None, sets global variable
* SIDE EFFECTS
*  affect global variable _Pts, which is input to Potential.CreateV### function factory macros
* SEE ALSO                   
*  VectorCF (), ComputeStreamline ()
*
******/
  #declare _PTs = _Atoms; // TODO: make shallow copy instead
#end                            

/****M* VectorField.inc/VectorCF
* PURPOSE
*  computes Coulomb vector field from 
*  assembly of charged molecules, passed as global array _Pts[][]
*  
* SYNOPSIS
*/
#macro VectorCF ( _rr, _sc )
/* 
* INPUTS
*  3Dvector _rr  - 3D space point, units - [A] 
*  float    _sc  - additional scaling factor, may be left _sc==1
*  garray   _PTs - array[N+1][8] of charges, passed as global variable, use macro DeclareStructure (Any_Set_of_Atoms), refer Structures.inc and Potential.inc for details
* OUTPUTS
*  Coulomb electric field vector in [V/Angstrem], governed by "qeff" factor defined in Potential.inc file
* SEE ALSO
*  DrawStreamLines, ComputeStreamline, Potential.inc
*   
******/

// _PTs( charge, x,y,z, [... not used ...] )    
 #local _sc = _sc*qeff;
 #local _vx = 0.0;
 #local _vy = 0.0;
 #local _vz = 0.0;

 #for(i, 1, _PTs[0][0]) 
     #local _R3 = pow(pow(_rr.x-_PTs[i][1],2) + pow(_rr.y-_PTs[i][2],2) + pow(_rr.z-_PTs[i][3],2), 1.5); // R^3
     #local _vx = _vx + _PTs[i][0]*(_rr.x-_PTs[i][1])/_R3;                     
     #local _vy = _vy + _PTs[i][0]*(_rr.y-_PTs[i][2])/_R3;
     #local _vz = _vz + _PTs[i][0]*(_rr.z-_PTs[i][3])/_R3;
 #end                       
 #local _vx = _vx*_sc;
 #local _vy = _vy*_sc;
 #local _vz = _vz*_sc;
 <_vx, _vy, _vz>
#end  // end  VectorCF() macro

/****M* VectorField.inc/ComputeStreamline
* PURPOSE
*  this macro computes nodes of single streamline only, for given line index _Lnum, 
*  using Runge-Kutta 4th order algorithm based on data provided by DeclareStructure () macro
*  Radius of the streamlines is governed by internal global variable _StrmLinRadius.    
*  _FatCoefficient is being used by ComputeFatStreamline macro variant of ComputeStreamline. Moderates scaling of the field strength
*  Until _StrmLinRadius>0 then constant value (_StrmLinRadius) is used. If opposite is true, dynamic scaling is activated. 
* SYNOPSIS
*/
#macro ComputeStreamline(_P0, _Npts, _Lnum) 
/* 
* INPUTS
*  3Dvector _P0   - 3D Start space point, units - [A] 
*  integer  _Npts - expected (maximum) number of nodes, 
*  integer  _Lnum - streamline index.
* SIDE EFFECTS
*  Radius of the streamlines is governed by internal global variable _StrmLinRadius.
*  Radius of the streamlines may depend on field strength so scaling factor _FatCoefficient as internal global var. is required. 
*  Computed line is stored in global variable StrmLineTable[][][] which must be defined BEFORE macro is called.
* SEE ALSO
*  VectorCF, DrawStreamLines
*   
******/
    #local _cFlux = sqrt(_Flux/pi);  // coefficien constant across mmacro          
    #local _absStrmLinRadius   =    abs(_StrmLinRadius);
    #local _abs50StrmLinRadius = 1000*abs(_StrmLinRadius);    
    #declare StrmLineTable[_Lnum][0][0] = _Npts;
    #local _VV = VectorCF(_P0, 1); // local electric vector [V/m]
    #if (_StrmLinRadius>0) 
       #declare StrmLineTable[_Lnum][1][0] = _StrmLinRadius; // scene units; vector length [V/m]=>radius of given node of streamline
    #else
       #declare StrmLineTable[_Lnum][1][0] = clip(_FatCoefficient*_cFlux/(sqrt(vlength(_VV))+Tiny), _absStrmLinRadius, _abs50StrmLinRadius); // scene units; vector length [V/m]=>radius of given node of streamline
    #end   
    #declare StrmLineTable[_Lnum][1][1] = _P0.x; // [A]
    #declare StrmLineTable[_Lnum][1][2] = _P0.y; // [A]
    #declare StrmLineTable[_Lnum][1][3] = _P0.z; // [A]
    
    #for(ind, 2, _Npts) // Runge-Kutta of 4 order           
        #local _vn = vlength( _VV ); // unary vector parallel to local vector field
        #if ((ind > 5) & ((_vn< _vnMin) | (_vn >_vnMax)) )
            #declare StrmLineTable[_Lnum][0][0] = ind-2;
            #if (Debug>1) 
               #debug concat("Break on line: ", str(_Lnum,5,0),", at: ", str((ind-1),4,0), "node \n")
            #end
            #break
        #else
            #local _vn = vnormalize( _VV ); // unary vector parallel to local vector field
            
            #local _k1 = _h*_vn;            // k1 (R-K)
            #local _VV = VectorCF((<_P0.x, _P0.y, _P0.z>+_h/2.0*_vn), 1); // x+h/2
            #local _k2 = _h*vnormalize( _VV );
            #local _k3 = _k2;
            #local _VV = VectorCF((<_P0.x, _P0.y, _P0.z>+_h*_vn), 1); // x+h/2
            #local _k4 = _h*vnormalize( _VV ); 
        
            #local _P1 = _P0+(_k1+2*_k2+2*_k3+_k4)/6.0;
             
            #if (_StrmLinRadius>0) 
               #declare StrmLineTable[_Lnum][ind][0] = _StrmLinRadius; // scene units; vector length [V/m]=>radius of given node of streamline
            #else
               #declare StrmLineTable[_Lnum][ind][0] = clip(_FatCoefficient*_cFlux/(sqrt(vlength(_VV))+Tiny), _absStrmLinRadius, _abs50StrmLinRadius); // scene units; vector length [V/m]=>radius of given node of streamline
            #end   
            #declare StrmLineTable[_Lnum][ind][1] = _P1.x; // [A]
            #declare StrmLineTable[_Lnum][ind][2] = _P1.y; // [A]
            #declare StrmLineTable[_Lnum][ind][3] = _P1.z; // [A]
            #local _P0 = _P1;
            #local _VV = VectorCF( _P0, 1); // local electric vector [V/m]
        #end
    #end
#end

/****M* VectorField.inc/DrawStreamLines
* PURPOSE
*  Draws streamlines based on Streamline table _SL, spline type _splt and texture _txt. 
*  Uses _EndingPointRad internal global variable
* SYNOPSIS
*/
#macro DrawStreamLines ( _SL, _splt, _txt )// - table, spline, texture
/* 
* INPUTS
*  garray     _SL   - streamlines table over N lines over N_i nodes
*  integer    _splt - interpolation type: 2 - bezier spline, 3 - cubic spline, other - linear_spline
*  texturedef _txt  - texture attached to ALL lines, may be simple or complex, ex. functional
* SIDE EFFECTS
*  Uses _EndingPointRad internal global variable, governing radius of extreme points.
* SEE ALSO
*  ComputeStreamline, VectorCF
*   
******/
    #if (Debug>1) 
      #debug concat("Tot. Lines: ", str(_SL[0][0][0],5,0),"\n")           
    #end  

    #for(jnd, 1, _SL[0][0][0]) 
        #if (Debug>1) 
           #debug concat("Line: ", str(jnd,5,0),"\n")           
        #end  

        #local _np = _SL[jnd][0][0];             
        #if (_np>2)
            sphere_sweep{//
               #switch(_splt)
                 #case( 2 ) 
                    b_spline      
                 #break
                 #case( 3 ) 
                    cubic_spline  
                 #break
                 #else 
                    linear_spline
               #end  
               
               #if ((_splt=2) | (_splt=3))
                  _np+2 // increase for Bezier & cubic interpolation _SL[jnd][0][0]
                  2*<_SL[jnd][ 1 ][1], _SL[jnd][ 1 ][2], _SL[jnd][ 1 ][3]> - <_SL[jnd][ 2 ][1], _SL[jnd][ 2 ][2], _SL[jnd][ 2 ][3]>, _SL[1][1][0]  
               #else
                  _np
               #end
                            
               #for(ind, 1, _np)            
                  #if (Debug>1) 
                    #debug concat("Line: ", str(jnd,5,0), ", Node: ", str(ind,5,0),"\n")           
                  #end  
                  < _SL[jnd][ind][1], _SL[jnd][ind][2], _SL[jnd][ind][3]>, _SL[jnd][ind][0]  
               #end              
    
               #if ((_splt=2) | (_splt=3))
                 2*<_SL[jnd][_np][1], _SL[jnd][_np][2], _SL[jnd][_np][3]> - <_SL[jnd][_np-1][1], _SL[jnd][_np-1][2], _SL[jnd][_np][3]>, _SL[jnd][_np][0]  
               #end
               texture{ _txt   
                 //   finish { scDullMirror } 
               } // end of texture 
            }
            #if (_EndingPointRad>0)
              sphere{ <_SL[jnd][ 1 ][1], _SL[jnd][ 1 ][2], _SL[jnd][ 1 ][3]>, _EndingPointRad texture{pigment{color rgb< 1.0, .1,  .1>} finish{Dull}}}//scDullMirror}}} // starting point                                                                  
              sphere{ <_SL[jnd][_np][1], _SL[jnd][_np][2], _SL[jnd][_np][3]>, _EndingPointRad texture{pigment{color rgb<  .1, .1, 1.0>} finish{Dull}}}//scDullMirror}}} // ending point
            #end  
         #end   
    #end
#end // #macro DrawStreamLines 


#end // #ifdef
// ==== end of _INC file ============ //
